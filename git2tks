#!/usr/bin/perl

use strict;
use Data::Dumper;
use Date::Format ();
use Date::Parse ();
use Getopt::Long;
use POSIX;

my $days  = 7; # how far back in time to we look?
my $user  = `whoami`;
my $starttime = 10; # What hour of the day do you start at?
chomp $user;

sub usage {

    print <<EOF;

 Run this *anywhere* on a OUA VM and it will dump your commits in a format for import into tks

 It will:
  * pull data from all 4 OUA repos
  * pull data from all local branches, if merged, each commit is only shown once
  * branch names are sanitized and become your tksrc WR aliases
  * can be run from anywhere NOT DONE

$0 -d 14   # go back 14 days
$0 -s 8    # I start at 8am
$0 -u jim  # Show someone


EOF
    exit;
}

GetOptions (
    "d|days=f"   => \$days,
    "s|start=f"  => \$starttime,
    "u|user=s"   => \$user,
) or die usage();


sub findCommits {
    my ($cwd, $system, $branch, $user, $days) = @_;

    my @commits;

    my $cmd = "git log --since=".$days.".days --author=$user $branch";
#    print "==$cmd==\n";
    my @res = split '\n', `$cmd`;

    $branch =~ s/\./-/g;
#    print Dumper (@res);

    while ($#res > -1){
        my $commit    = substr(shift @res,7,10);
        my $author    = shift @res;
        if (substr($author,0,5) eq 'Merge'){
            $author    = shift @res;
        }
        my $date      = substr(shift @res,8);
        my $timestamp = Date::Parse::str2time($date);
        my $dud       = shift @res;
        my $msg       = substr(shift @res, 4);
        my $dud       = shift @res;

        my @stuff = ($timestamp,$date,$msg,$branch,$commit, $system);
        push @commits, \@stuff; 

    }
    return @commits;

}


sub findCommitsForRepo {

    my ($cwd, $system, $user, $days) = @_;
    my @coms;

    my @branches = split '\n', `git branch`;

#print Dumper(@branches);
    foreach my $branch (@branches){
        $branch = substr($branch,2);
        push @coms, findCommits('.', 'moodle', $branch, $user, $days);
    }
    return @coms;
}

my @commits = findCommitsForRepo('.', 'moodle', $user, $days);


my $lastdate='';
my $lasttime = $starttime;
my $daytotal = 0;

@commits = sort { $a->[0] <=> $b->[0] or $b->[3] cmp $a->[3] } @commits;

sub ft {
    my ($hours) = @_;
    my $dh = floor($hours);
    my $dm = $hours - $dh;

    return sprintf "%2s:%02d", $dh, $dm * 60;
}

foreach my $commit (@commits){

    my @com = @$commit;
#print Dumper ($commit);

    my $date = Date::Format::time2str("\n%Y-%m-%d # %A \n",$com[0], 'GMT');
    my $time = Date::Format::time2str("%H:%M ",$com[0], 'AEST');
    if ($date ne $lastdate){

        if ($daytotal){
            print "#               ".ft($daytotal)."   total hours\n";
        }
        print "$date";
        $lasttime = $starttime;
        $daytotal = 0;
    }
    $time = substr($time,0,2) + substr($time,3,2)/60 ;
    my $delta = $time - $lasttime;
    $daytotal += $delta;
#    if ($delta == 0){ next; } # this collapses commits on two branches
    printf "%-15s  %.2f   %s (%s: %s)\n", $com[3], $delta, $com[2], $com[5], $com[4];

    $lastdate = $date;
    $lasttime = $time;
}
print "#               ".ft($daytotal)."   total hours\n\n";

# TODO 
# run it across all repo's
# assume a start time of X - make this a param


