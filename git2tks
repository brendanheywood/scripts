#!/usr/bin/perl
#
# TODO 
# * Config it to run across multiple repos
#

sub usage {
    use File::Basename;
    my $cmd = basename($0);
    print <<EOF;
Converts your git commits into TKS format

It will:
  * pull data from current repo
  * pull data from all local branches, each duplicate commit will be present
    but with zero time (tks ignores it but you can manipulate it)
  * branch names are sanitized and become your .tksrc WR aliases
  * Assumes we start useful work at 10am (emails etc should be a separate WR record)

> $cmd -d 14   # show 14 days (default to 7)
> $cmd -s 8    # I start at 8am (default 10am)
> $cmd -u jim  # Show someone else's data

EOF
    exit;
}

use strict;
use Data::Dumper;
use Date::Format ();
use Date::Parse ();
use Getopt::Long;
use POSIX;

my $days  = 7; # how far back in time to we look?
my $user  = `whoami`;
my $help = 0;
my $starttime = 10; # What hour of the day do you start at?
chomp $user;


GetOptions (
    "d|days=f"   => \$days,
    "s|start=f"  => \$starttime,
    "u|user=s"   => \$user,
    "h|help"     => \$help,
) or die usage();

if( $help ){
    usage();
    exit;
}


sub findCommits {
    my ($cwd, $system, $branch, $user, $days) = @_;
    my @commits;
    my $cmd = "git log --since=".$days.".days --author=$user $branch";
    my @res = split '\n', `$cmd`;
    $branch =~ s/\./-/g;

    while ($#res > -1){
        my $commit    = substr(shift @res,7,10);
        my $author    = shift @res;
        if (substr($author,0,5) eq 'Merge'){
            $author    = shift @res;
        }
        my $date      = substr(shift @res,8);
        my $timestamp = Date::Parse::str2time($date);
        my $dud       = shift @res;
        my $msg       = substr(shift @res, 4);
        my $dud       = shift @res;

        my @stuff = ($timestamp,$date,$msg,$branch,$commit, $system);
        push @commits, \@stuff; 
    }
    return @commits;
}


sub findCommitsForRepo {
    my ($cwd, $system, $user, $days) = @_;
    my @coms;
    my @branches = split '\n', `git branch`;
    foreach my $branch (@branches){
        $branch = substr($branch,2);
        push @coms, findCommits('.', 'moodle', $branch, $user, $days);
    }
    return @coms;
}

my @commits = findCommitsForRepo('.', 'moodle', $user, $days);

my $lastdate='';
my $lasttime = $starttime;
my $daytotal = 0;

@commits = sort { $a->[0] <=> $b->[0] or $b->[3] cmp $a->[3] } @commits;

sub ft {
    my ($hours) = @_;
    my $dh = floor($hours);
    my $dm = $hours - $dh;
    return sprintf "%2s:%02d", $dh, $dm * 60;
}

foreach my $commit (@commits){

    my @com = @$commit;
    my $date = Date::Format::time2str("\n%Y-%m-%d # %A \n",$com[0], 'GMT');
    my $time = Date::Format::time2str("%H:%M ",$com[0], 'AEST');

    if ($date ne $lastdate){
        if ($daytotal){
            print "#               ".ft($daytotal)."   total hours\n";
        }
        print "$date";
        $lasttime = $starttime;
        $daytotal = 0;
    }

    $time = substr($time,0,2) + substr($time,3,2)/60 ;
    my $delta = $time - $lasttime;
    $daytotal += $delta;
#    if ($delta == 0){ next; } # this collapses commits on two branches
    printf "%-15s  %.2f   %s (%s: %s)\n", $com[3], $delta, $com[2], $com[5], $com[4];

    $lastdate = $date;
    $lasttime = $time;
}
print "#               ".ft($daytotal)."   total hours\n\n";


